<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="keywords" content="HTML, CSS" />
    <meta name="description" content="?????" />
    <meta name="author" content="Pedro M. M. de Paula" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>?????</title>
    <!--link rel="stylesheet" href="styles/reset.css"-->
    <link rel="stylesheet" href="styles/style.css" />
    <!-- Computer Modern Serif-->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/aaaakshat/cm-web-fonts@latest/fonts.css"
    />
  </head>
  <body>
    <nav id="navbar">
      <header>Git Documentation</header>
      <ul>
        <li><a class="nav-link" href="#Introduction">Introduction</a></li>
        <li><a class="nav-link" href="#What_is_Git?">What is Git?</a></li>
        <li>
          <a class="nav-link" href="#Installing_Git">Installing Git</a>
        </li>
        <li>
          <a class="nav-link" href="#Configuring_Git">Configuring Git</a>
        </li>
        <li>
          <a class="nav-link" href="#Searching_for_Help">Searching for Help</a>
        </li>
        <li>
          <a class="nav-link" href="#Initializing_a_Repository"
            >Initializing a Repository</a
          >
        </li>
        <li>
          <a class="nav-link" href="#File_States_in_a_Repository"
            >File States in a Repository</a
          >
        </li>
        <li>
          <a class="nav-link" href="#Checking_the_Status_of_Your_Files"
            >Checking the Status of Your Files</a
          >
        </li>
        <li>
          <a class="nav-link" href="#Tracking_New_Files">Tracking New Files</a>
        </li>
        <li>
          <a class="nav-link" href="#Staging_Modified_Files"
            >Staging Modified Files</a
          >
        </li>
        <li>
          <a class="nav-link" href="#Committing_Your_Changes"
            >Committing Your Changes</a
          >
        </li>
        <li><a class="nav-link" href="#Removing_Files">Removing Files</a></li>
        <li><a class="nav-link" href="#References">References</a></li>
      </ul>
    </nav>
    <main id="main-doc">
      <section class="main-section" id="Introduction">
        <header>Introduction</header>
        <p>
          This document is an introductory guide on the Git version control
          system. It covers all the information needed to locally version
          control your files, from the instalation of Git up to
          <em>committing</em> and
          <em>removing</em>
          files.
        </p>
        <p>
          With that being said, this is a list of things you should know before
          reading it:
        </p>
        <ul>
          <li>
            This guide uses Git on the command line, hence I will assume some
            familiarity with it;
          </li>
          <li>
            This guide is based in Git on Linux, so all the examples are Linux
            based;
          </li>
          <li>This guide does not cover Git remotes, branches, etc...</li>
        </ul>
      </section>
      <section class="main-section" id="What_is_Git?">
        <header>What is Git?</header>
        <p>
          Git is a free and open-source
          <a href="https://en.wikipedia.org/wiki/Distributed_version_control"
            >distributed version control system</a
          >
          created by Linus Torvalds in 2005 for development of the Linux kernel,
          with other kernel developers contributing to its initial development.
        </p>
        <p>
          It works storing data like a series of snapshot of a miniature
          filesystem. Every time you <em>commit</em>, i.e., save the state of
          your files, Git basically takes a picture of what your files look like
          at that moment and stores a reference to that snapshot.
        </p>
        <p>For this, Git assigns three <em>states</em> to your files:</p>
        <ul>
          <li>
            <em>Modified</em>, files that changed but were not
            <em>committed</em>.
          </li>
          <li>
            <em>Staged</em>, files marked to go in its current version to the
            next <em>commit</em>.
          </li>
          <li>
            <em>Committed</em>, files the data is safely stored in your local
            database.
          </li>
        </ul>
        <p>
          Having said all this, Git is a very fast, simple and strong tool for
          version control as you will see in the sections below.
        </p>
      </section>
      <section class="main-section" id="Installing_Git">
        <header>Installing Git</header>
        <p>
          Installing Git on Linux via a binary installer is pretty simple, since
          you can use the package management tool that comes with your
          distribution. For a Debian-based distribution (like Ubuntu) you can
          run:
        </p>
        <pre><code>$ sudo apt install git-all</code></pre>
        <p>
          For other distributions you can check on the
          <a href="https://git-scm.com/download/linux">Git website</a>.
        </p>
      </section>
      <section class="main-section" id="Configuring_Git">
        <header>Configuring Git</header>
        <p>
          With Git installed, the first thing you should do is customize it to
          look and work the way you want. You can do this with the
          <code>git config</code> which lets you access and change the
          configuration variables.
        </p>
        <p>
          The main use for <code>git config</code> is to set your user name and
          email addres which will later be used in your <em>commits</em>. For
          this, you just need to run:
        </p>
        <pre><code>$ git config --global user.name "The name you want"
$ git config --global user.email your@email.com</code></pre>
        <p>
          To learn more about the <code>git config</code> command and its use,
          you can access
          <a
            href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration#_git_config"
            >the chapter on customization</a
          >.
        </p>
      </section>
      <section class="main-section" id="Searching_for_Help">
        <header>Searching for Help</header>
        <p>
          If you ever need <em>help</em>, there are three equivalent ways to get
          the comprehensive manual page help for any of the Git commands:
        </p>
        <pre><code>$ git help &lt;verb&gt;
$ git &lt;verb&gt; --help
$ man git -&lt;verb&gt;</code></pre>
        <p>
          For example, you can get the manpage help for the
          <code>git add</code> command by running this:
        </p>
        <pre><code>$ git help add</code></pre>
        <p>
          These commands are nice because you can access them anywhere, even
          offline.
        </p>
      </section>
      <section class="main-section" id="Initializing_a_Repository">
        <header>Initializing a Repository</header>
        <p>
          Now that Git is set up, you can start using it to version control your
          files. The first step for this is to <em>initialize</em> a repository,
          where you will store those files, with the commmand
          <code>git init</code>.
        </p>
        <p>
          Let's say that you have a local directory, call it
          <code>/home/user/loc_dir</code>, that you want to turn into a
          repository. To do this, you can first go to that directory and then
          <em>initialize</em> it:
        </p>
        <pre><code>$ cd /home/user/loc_dir
$ git init</code></pre>
        <p>
          Or you can simply <em>initialize</em> it from your working directory:
        </p>
        <pre><code>$ git init /home/user/loc_dir</code></pre>
        <p>
          In both cases Git creates a new subdirectory named
          <code>.git</code> that contains all of your necessary repository files
          — a Git repository skeleton. Moreover, if the directory provided in
          the second case didn't exist, it would be created.
        </p>
        <p>
          <strong>Remark:</strong> At this point, nothing in your repository is
          <em>tracked</em>. To start version-controlling existing files you
          should <em>track</em> these files and do an initial <em>commit</em>.
          You will learn how to accomplish this in the next sections.
        </p>
      </section>
      <section class="main-section" id="File_States_in_a_Repository">
        <header>File States in a Repository</header>
        <p>
          With a Git repository, you can start making changes and
          <em>committing</em> snapshots of those changes into your repository.
          Prior to this you have to know that each file in your repository can
          be in one of two <em>states</em>:
        </p>
        <ul>
          <li>
            <em>Tracked</em> files, files that were in your last snapshot or in
            the staging area. These can be in the state of <em>unmodified</em>,
            <em>modified</em>, or <em>staged</em>.
          </li>
          <li>
            <em>Untracked</em> files, files that were not in your last snapshot
            and are not in your staging area.
          </li>
        </ul>
        <p>
          When you <em>initialize</em> a repository every file in the repository
          will be <em>untracked</em>, since they were not in the last snapshot
          and are not in the staging area.
        </p>
        <p>
          Below is the image that you should have in your mind when working with
          your local repository.
        </p>
        <figure>
          <img
            src="images/git_img.png"
            width="682"
            heith="286"
            alt="File states and state changing commands."
          />
          <figcaption>
            All the file <em>states</em> and how the Git commands change these
            <em>states</em>.
          </figcaption>
        </figure>
        <p>We will talk more about these commands in the sections below.</p>
      </section>
      <section class="main-section" id="Checking_the_Status_of_Your_Files">
        <header>Checking the Status of Your Files</header>
        <p>
          Before learning how to change a file <em>state</em>, you should know,
          first, how to check its <em>state</em>. The main tool that will help
          you in this is the <code>git status</code> command.
        </p>
        <p>
          Let's go back to your <code>/home/user/loc_dir</code> repository. If
          you run <code>git status</code> right after you
          <em>initialized</em> it (assuming it was empty), you should see
          something like this:
        </p>
        <pre><code>$ git status
On branch master
No commits yet
nothing to commit</code></pre>
        <p>
          This means that you don't have a snapshot of your repository yet, and
          that nothing has been <em>modified</em>.
        </p>
        <p>
          Now, if you add a text file, call it <code>Text</code>, to your
          repository and run <code>git status</code>, you will see:
        </p>
        <pre><code>$ touch text
$ git status
On branch master
No commits yet
Untracked files:
  (use "git add &lt;Text&gt;..." to include in what will be committed)
  
    Text
  
nothing added to commit but untracked files present (use "git add" to track)</code></pre>
        <p>
          This means that Git sees that you added <code>Text</code> to the
          repository but it is <em>untracked</em>. Git won’t start including it
          in your snapshots until you explicitly tell it to do, so let’s start
          <em>tracking</em>
          the file.
        </p>
      </section>
      <section class="main-section" id="Tracking_New_Files">
        <header>Tracking New Files</header>
        <p>
          After digressing a bit on file <em>states</em>, let's return to
          version controlling your files. The second step for this is to
          <em>add</em> your files to the staging area using the
          <code>git add</code> command.
        </p>
        <p>
          Back to our example, let's begin <em>tracking</em> the
          <code>Text</code> file. For this, you can run:
        </p>
        <pre><code>$ git add Text</code></pre>
        <p>
          If you run the <code>git status</code> command again, you can see that
          the <code>Text</code> file is now <em>tracked</em> and
          <em>staged</em> to be <em>committed</em>:
        </p>
        <pre><code>$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git restore --staged &lt;file&gt;..." to unstage)

    new file:  Text</code></pre>
        <p>
          You can tell that it is <em>staged</em> because it is under "Changes
          to be commited" heading. If you <em>commit</em> at this point, the
          version of the file at the time you ran <code>git add</code> is what
          will be in the subsequent historical snapshot.
        </p>
        <p>
          <strong>Remark</strong>: the <code>git add</code> command takes a path
          name for either a file or a directory; if it’s a directory, the
          command
          <em>adds</em>
          all the files in that directory recursively.
        </p>
      </section>
      <section class="main-section" id="Staging_Modified_Files">
        <header>Staging Modified Files</header>
        <p>
          Now that your files are <em>tracked</em>, you may want to
          <em>modify</em> them before you <em>commit</em>. In this case,you have
          to use the <code>git add</code> command to <em>stage</em> these
          changes.
        </p>
        <p>
          Returning to our example, let's write something, say "I am learning
          Git", in the <code>Text</code> file to see how Git reacts. If you run
          the <code>git status</code> command, you will get something that looks
          like this:
        </p>
        <pre><code>$ echo "I am learning Git" &gt;&gt; Text
$ git status
Changes to be committed:
  (use "git restore --staged &lt;file&gt;..." to unstage)

    new file:  Text

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:  Text</code></pre>
        <p>
          The <code>Text</code> file also appears now under "Changes not staged
          for commit" with a <em>modified</em> tag. This means that, although it
          is being <em>tracked</em>, the modification we did in the file is not
          yet <em>staged</em>. To <em>stage</em> it, you run the
          <code>git add</code> command.
        </p>
        <p>
          Using <code>git add</code> to stage the <code>Text</code> file and
          then running <code>git status</code> again yields:
        </p>
        <pre><code>$ git add Text
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:  Text</code></pre>
        <p>
          As you can see, the <code>Text</code> file is <em>staged</em> and will
          go into your next <em>commit</em>.
        </p>
      </section>
      <section class="main-section" id="Committing_Your_Changes">
        <header>Committing Your Changes</header>
        <p>
          Now that every file you want is in the staging area, you can finally
          <em>commit</em> your changes. Remember that anything that is still
          <em>unstaged</em> won’t go into this <em>commit</em>. They will stay
          as <em>modified</em> files on your disk.
        </p>
        <p>
          Going back to our example, everything was <em>staged</em> last time we
          checked so we are ready to <em>commit</em>. The simplest way to do
          this is to type:
        </p>
        <pre><code>$ git commit</code></pre>
        <p>
          Doing so launches your editor of choice set by your shell’s EDITOR
          environment variable (usually <code>vim</code> or <code>emacs</code>).
        </p>
        <p>
          The editor displays the following text (this example is a
          <code>vim</code> screen):
        </p>
        <pre><code># Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
#
# Initial commit
#
# Changes to be committed:
#   new file:  Text
#
~
~
~
".git/COMMIT_EDITMSG" 10L, 224C</code></pre>
        <p>
          As you see, the default commit message contains the latest output of
          the <code>git status</code> command commented out and one empty line
          on top. You can remove these comments and type your commit message, or
          you can leave them there to help you remember what you’re
          <em>committing</em>. When you exit the editor, Git creates your
          <em>commit</em> with that commit message (with the comments).
        </p>
        <p>
          Remember that the <em>commit</em> records the snapshot you set up in
          your staging area. Anything you didn’t stage is still sitting there
          <em>modified</em>; you can do another <em>commit</em> to add it to
          your history. Every time you perform a <em>commit</em>, you’re
          recording a snapshot of your project that you can revert to or compare
          to later.
        </p>
      </section>
      <section class="main-section" id="Removing_Files">
        <header>Removing Files</header>
        <p>
          You finally have a version controlled repository, so, lastly, you
          should learn how to <em>remove</em> files from Git. For this, you use
          the <code>git rm</code> command which also removes the file from your
          working directory so you don’t see it as an <em>untracked</em> file .
        </p>
        <p>
          Returning to our example, let's delete the <code>Text</code> file from
          the repository and run <code>git status</code>:
        </p>
        <pre><code>$ rm Text
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add/rm &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)
 
    deleted:  Text

no changes added to commit (use "git add" and/or "git commit -a")</code></pre>
        <p>
          Observe that <code>Text</code> shows up under the “Changes not staged
          for commit”, i.e., the removal is <em>unstaged</em>. <em>Stage</em> it
          using the <code>git rm</code> command and run
          <code>git status</code> again to get:
        </p>
        <pre><code>$ git rm Text
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    deleted:  Text</code></pre>
        <p>
          Now the removal is <em>staged</em>, so the file will be gone and no
          longer <em>tracked</em> the next time you <em>commit</em>.
        </p>
        <p>
          <strong>Remark:</strong> If you <em>modify</em> a file or
          <em>add</em> it to the staging area, you must use
          <code>git rm -f</code> to force the removal. This is a safety feature
          to prevent accidental removal of data that hasn’t yet been recorded in
          a snapshot and that can’t be recovered from Git.
        </p>
      </section>
      <section class="main-section" id="References">
        <header>References</header>
        <p>
          All the documentation in this page is taken from
          <a href="https://git-scm.com/book/en/v2">Pro Git book</a>.
        </p>
      </section>
    </main>
  </body>
</html>
